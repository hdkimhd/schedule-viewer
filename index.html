<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>개발 일정 시각화 (Shared)</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <style>
        :root {
            --primary-color: #333;
            --border-color: #ddd;
            --bg-color: #f9f9f9;
            --bar-height: 30px;
            --row-height: 80px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background-color: #fff;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
        }
        
        .status-bar {
            text-align: center;
            font-size: 0.9em;
            margin-bottom: 10px;
            padding: 5px;
            border-radius: 4px;
        }
        .status-connected { background-color: #d4edda; color: #155724; }
        .status-disconnected { background-color: #f8d7da; color: #721c24; }

        /* Input Section */
        .controls {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: flex-end;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-size: 0.9em;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .control-group input, .control-group select {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background-color: #0056b3;
        }

        button.clear-btn {
            background-color: #dc3545;
        }
        button.clear-btn:hover {
            background-color: #a71d2a;
        }

        .action-buttons {
            margin-left: auto;
            display: flex;
            gap: 10px;
        }

        /* Zoom Control */
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 20px;
            padding-left: 20px;
            border-left: 1px solid #ccc;
        }

        /* Chart Section */
        .chart-container {
            overflow-x: auto;
            border: 1px solid var(--border-color);
            position: relative;
            background: white;
            max-height: 80vh; /* Allow vertical scroll */
        }

        .timeline-header {
            display: flex;
            border-bottom: 2px solid var(--primary-color);
            background: #eee;
            position: sticky;
            top: 0;
            z-index: 30; /* Higher than content */
            min-width: fit-content; /* Ensure header stretches */
        }

        .category-header-cell {
            min-width: 100px;
            width: 100px;
            padding: 10px;
            font-weight: bold;
            background: #d0d0d0;
            border-right: 2px solid var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 40;
        }

        .model-header-cell {
            min-width: 100px;
            width: 100px;
            padding: 10px;
            font-weight: bold;
            background: #e0e0e0;
            border-right: 2px solid var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            position: sticky;
            left: 100px; /* Adjusted for category column */
            z-index: 40;
        }

        .months-container {
            display: flex;
            flex-grow: 1;
        }

        .month-cell {
            flex: 1;
            min-width: 100px;
            text-align: center;
            padding: 5px 0;
            border-right: 1px solid var(--border-color);
            font-size: 0.9em;
            background: #eee;
            box-sizing: border-box;
        }
        
        .year-label {
            display: block;
            font-size: 0.8em;
            color: #666;
        }

        .chart-body {
            position: relative;
            min-width: fit-content;
        }

        /* New Grouping Structure */
        .category-group {
            display: flex;
            border-bottom: 2px solid #999; /* Stronger separator between categories */
        }

        .category-name {
            min-width: 100px;
            width: 100px;
            background: #e8e8e8;
            border-right: 2px solid var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 20;
            font-size: 0.9em;
            writing-mode: vertical-rl; /* Vertical text for better fit */
            transform: rotate(180deg);
            padding: 10px 0;
        }

        .category-models {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }

        .model-row {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            min-height: var(--row-height);
            position: relative;
        }
        
        .model-row:last-child {
            border-bottom: none; /* Remove bottom border for last item in group */
        }

        .model-name {
            min-width: 100px;
            width: 100px;
            background: #f4f4f4;
            border-right: 2px solid var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
            position: sticky;
            left: 100px; /* Adjusted for category column */
            z-index: 10;
        }

        .timeline-track {
            flex-grow: 1;
            position: relative;
            background-image: linear-gradient(to right, transparent 99%, #eee 1%);
            /* background-size set by JS */
        }

        .event-bar {
            position: absolute;
            height: var(--bar-height);
            background-color: #ddd;
            border: 1px solid #999;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            color: #000;
            overflow: hidden;
            white-space: nowrap;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            top: 10px; /* Default top */
            cursor: pointer;
            transition: transform 0.1s;
            line-height: 1.2;
            padding: 2px 0;
        }

        .event-bar:hover {
            transform: scale(1.02);
            z-index: 100;
        }

        .event-bar .dates {
            font-size: 0.7em;
            margin-top: 2px;
            width: 100%;
            text-align: center;
            opacity: 0.7;
        }
        
        .event-bar.phase-2 {
            top: 45px; /* Offset for overlapping events if needed */
        }

        /* Arrow style for timeline end */
        .timeline-track::after {
            content: '';
            position: absolute;
            right: -10px;
            top: 50%;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-left: 10px solid #ccc;
            transform: translateY(-50%);
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 1000;
        }
        
        .delete-btn {
            position: absolute;
            right: 2px;
            top: 2px;
            background: red;
            color: white;
            border: none;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 12px;
            line-height: 14px;
            text-align: center;
            cursor: pointer;
            display: none;
            z-index: 101;
        }
        
        .event-bar:hover .delete-btn {
            display: block;
        }
    </style>
</head>
<body>

    <h1>Project Schedule Viewer (Shared)</h1>
    <div id="status" class="status-bar status-disconnected">데이터베이스 연결 대기중...</div>

    <div class="controls">
        <div class="control-group">
            <label for="baseYear">기준 연도 (Base Year)</label>
            <input type="number" id="baseYear" value="2025" style="width: 80px;">
        </div>
        <div class="control-group">
            <label for="categoryName">제품군 (Category)</label>
            <select id="categoryName">
                <option value="Soundbar">Soundbar</option>
                <option value="SoundSuite">SoundSuite</option>
                <option value="무선스피커">무선스피커</option>
                <option value="이어버드">이어버드</option>
            </select>
        </div>
        <div class="control-group">
            <label for="modelName">모델명 (Model)</label>
            <input type="text" id="modelName" placeholder="e.g., S7" value="S7">
        </div>
        <div class="control-group">
            <label for="eventPhase">이벤트 단계 (Phase)</label>
            <input type="text" id="eventPhase" placeholder="e.g., FC, PV" value="FC">
        </div>
        <div class="control-group">
            <label for="eventRound">차수 (Round)</label>
            <select id="eventRound">
                <option value="">없음 (None)</option>
                <option value="1차">1차</option>
                <option value="2차">2차</option>
                <option value="3차">3차</option>
                <option value="4차">4차</option>
                <option value="5차">5차</option>
                <option value="6차">6차</option>
                <option value="7차">7차</option>
                <option value="8차">8차</option>
                <option value="9차">9차</option>
                <option value="10차">10차</option>
            </select>
        </div>
        <div class="control-group">
            <label for="startDate">시작일 (Start)</label>
            <input type="date" id="startDate">
        </div>
        <div class="control-group">
            <label for="endDate">종료일 (End)</label>
            <input type="date" id="endDate">
        </div>
        <div class="control-group">
            <label for="eventColor">색상 (Color)</label>
            <input type="color" id="eventColor" value="#e0e0e0">
        </div>
        <div class="control-group">
            <label for="rowPosition">위치 (Row)</label>
            <select id="rowPosition">
                <option value="top">상단 (Top)</option>
                <option value="bottom">하단 (Bottom)</option>
            </select>
        </div>
        <button onclick="addEvent()">추가 (Add)</button>
        
        <div class="action-buttons">
            <button class="secondary-btn" onclick="toggleViewMode()" id="viewModeBtn">전체 보기 (Full Year)</button>
            <button class="clear-btn" onclick="clearEvents()">전체 초기화 (Clear All)</button>
        </div>
    </div>

    <div class="chart-container" id="chartContainer">
        <div class="timeline-header" id="timelineHeader"></div>
        <div class="chart-body" id="chartBody"></div>
    </div>
    
    <div id="tooltip" class="tooltip"></div>

<script>
    // --- 1. Firebase 설정 (여기에 복사한 내용을 붙여넣으세요) ---
    // 예시:
    // const firebaseConfig = {
    //   apiKey: "AIzaSy...",
    //   authDomain: "...",
    //   projectId: "...",
    //   ...
    // };
    
    // [중요] 아래 변수를 본인의 설정으로 교체해야 작동합니다!
  const firebaseConfig = {
    apiKey: "AIzaSyBVIRGA0AeE8qMOYPYXDgda0abagXi8kpM",
    authDomain: "schedule-share-268fa.firebaseapp.com",
    projectId: "schedule-share-268fa",
    storageBucket: "schedule-share-268fa.firebasestorage.app",
    messagingSenderId: "635764525782",
    appId: "1:635764525782:web:98e476cfd32c090e5e5777",
    measurementId: "G-G33ZM9GVDY"
  };
    // -------------------------------------------------------

    // State
    let events = [];
    let baseYear = 2025;
    let db = null;
    let isFullView = false;
    const DOC_ID = 'shared_schedule'; // Document ID in Firestore

    // Constants
    const CATEGORY_ORDER = ["Soundbar", "SoundSuite", "무선스피커", "이어버드"];

    // Initialize
    window.onload = () => {
        initFirebase();
        
        const today = new Date();
        // Set default dates: Start = Today, End = End of Current Month
        const start = new Date();
        const end = new Date(today.getFullYear(), today.getMonth() + 1, 0);
        
        document.getElementById('startDate').valueAsDate = start;
        document.getElementById('endDate').valueAsDate = end;
    };
    
    function toggleViewMode() {
        isFullView = !isFullView;
        const btn = document.getElementById('viewModeBtn');
        btn.textContent = isFullView ? "기본 보기 (Default View)" : "전체 보기 (Full Year)";
        renderChart();
    }

    function initFirebase() {
        if (!firebaseConfig.apiKey) {
            updateStatus('Firebase 설정이 필요합니다. index.html 코드를 수정해주세요.', false);
            return;
        }

        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.firestore();
            
            // Real-time Listener
            db.collection('schedules').doc(DOC_ID).onSnapshot((doc) => {
                if (doc.exists) {
                    const data = doc.data();
                    events = data.events || [];
                    baseYear = data.baseYear || 2025;
                    
                    document.getElementById('baseYear').value = baseYear;
                    renderChart();
                    updateStatus('데이터 동기화 완료 (실시간)', true);
                } else {
                    // First time initialization
                    saveToFirebase(); 
                    updateStatus('새 데이터베이스 생성됨', true);
                }
            }, (error) => {
                console.error(error);
                updateStatus('데이터 불러오기 실패: ' + error.message, false);
            });

        } catch (e) {
            console.error(e);
            updateStatus('Firebase 초기화 오류', false);
        }
    }

    function updateStatus(msg, isSuccess) {
        const el = document.getElementById('status');
        el.textContent = msg;
        el.className = 'status-bar ' + (isSuccess ? 'status-connected' : 'status-disconnected');
    }

    // Update base year
    document.getElementById('baseYear').addEventListener('change', (e) => {
        baseYear = parseInt(e.target.value);
        saveToFirebase(); // Sync change
    });

    function addEvent() {
        if (!db) return alert('데이터베이스에 연결되지 않았습니다.');

        const category = document.getElementById('categoryName').value;
        const model = document.getElementById('modelName').value;
        
        const phase = document.getElementById('eventPhase').value;
        const round = document.getElementById('eventRound').value;
        const name = round ? `${phase} ${round}` : phase;

        const start = document.getElementById('startDate').value;
        const end = document.getElementById('endDate').value;
        const color = document.getElementById('eventColor').value;
        const position = document.getElementById('rowPosition').value;

        if (!model || !start || !end) {
            alert('모든 필드를 입력해주세요.');
            return;
        }

        events.push({
            id: Date.now(),
            category: category || 'Uncategorized',
            model,
            name,
            phase, // Store separately for aggregation
            round, // Store separately
            start,
            end,
            color,
            position
        });

        saveToFirebase();
    }
    
    function deleteEvent(id) {
        if(confirm('이 일정을 삭제하시겠습니까? (모든 사용자에게 반영됩니다)')) {
            events = events.filter(e => e.id !== id);
            saveToFirebase();
        }
    }

    function clearEvents() {
        if(confirm('정말 모든 일정을 삭제하시겠습니까? (모든 사용자에게 반영됩니다)')) {
            events = [];
            saveToFirebase();
        }
    }

    function saveToFirebase() {
        if (!db) return;
        
        db.collection('schedules').doc(DOC_ID).set({
            baseYear: baseYear,
            events: events,
            lastUpdated: firebase.firestore.FieldValue.serverTimestamp()
        })
        .catch((error) => {
            console.error("Error writing document: ", error);
            alert('저장 실패: ' + error.message);
        });
    }

    // --- Rendering ---
    function renderChart() {
        const header = document.getElementById('timelineHeader');
        const body = document.getElementById('chartBody');
        
        header.innerHTML = '';
        body.innerHTML = '';

        // Determine Date Range
        let chartStart, totalMonths;
        const today = new Date();

        if (isFullView) {
            chartStart = new Date(baseYear, 0, 1);
            totalMonths = 15; // Fixed 15 months for full view
        } else {
            // Default: Previous Month, Current Month, Next Month (Total 3 months)
            chartStart = new Date(today.getFullYear(), today.getMonth() - 1, 1);
            totalMonths = 3; 
        }
        
        // Calculate Chart End (First day of the month AFTER the last month)
        const chartEnd = new Date(chartStart.getFullYear(), chartStart.getMonth() + totalMonths, 1);

        // --- Dynamic Column Width Calculation ---
        // 1. Identify months with events
        const activeMonths = new Set();
        events.forEach(e => {
            const s = new Date(e.start);
            const end = new Date(e.end);
            
            // Check overlap with chart range
            if (s < chartEnd && end > chartStart) {
                // Iterate through months this event touches
                let current = new Date(s.getFullYear(), s.getMonth(), 1);
                if (current < chartStart) current = new Date(chartStart);
                
                while (current < end && current < chartEnd) {
                    const key = `${current.getFullYear()}-${current.getMonth()}`;
                    activeMonths.add(key);
                    current.setMonth(current.getMonth() + 1);
                }
            }
        });

        // 2. Assign weights and calculate positions
        const monthConfig = [];
        let totalWeight = 0;

        for (let i = 0; i < totalMonths; i++) {
            const d = new Date(chartStart.getFullYear(), chartStart.getMonth() + i, 1);
            const key = `${d.getFullYear()}-${d.getMonth()}`;
            
            // Weight: 3 if active, 1 if empty
            const weight = activeMonths.has(key) ? 3 : 1;
            
            monthConfig.push({
                date: d,
                weight: weight,
                startPercent: 0, // Will be calculated
                widthPercent: 0  // Will be calculated
            });
            totalWeight += weight;
        }

        // 3. Calculate percentages
        let currentPercent = 0;
        monthConfig.forEach(m => {
            m.startPercent = currentPercent;
            m.widthPercent = (m.weight / totalWeight) * 100;
            currentPercent += m.widthPercent;
        });

        // Helper to get position for a specific date
        const getDatePosition = (date) => {
            if (date < chartStart) return 0;
            if (date >= chartEnd) return 100;

            // Find which month this date belongs to
            // Since monthConfig is ordered, we can find index
            let monthIndex = (date.getFullYear() - chartStart.getFullYear()) * 12 + (date.getMonth() - chartStart.getMonth());
            
            if (monthIndex < 0) return 0;
            if (monthIndex >= monthConfig.length) return 100;

            const config = monthConfig[monthIndex];
            
            // Calculate offset within the month
            const monthStart = new Date(config.date.getFullYear(), config.date.getMonth(), 1);
            const nextMonth = new Date(config.date.getFullYear(), config.date.getMonth() + 1, 1);
            const daysInMonth = (nextMonth - monthStart) / (1000 * 60 * 60 * 24);
            const dayOffset = (date - monthStart) / (1000 * 60 * 60 * 24);
            
            return config.startPercent + (dayOffset / daysInMonth) * config.widthPercent;
        };


        // 1. Render Header
        const categoryHeader = document.createElement('div');
        categoryHeader.className = 'category-header-cell';
        categoryHeader.textContent = 'Category';
        header.appendChild(categoryHeader);

        const modelHeader = document.createElement('div');
        modelHeader.className = 'model-header-cell';
        modelHeader.textContent = 'Model';
        header.appendChild(modelHeader);

        const monthsContainer = document.createElement('div');
        monthsContainer.className = 'months-container';
        
        monthConfig.forEach(config => {
            const m = config.date.getMonth() + 1;
            const y = config.date.getFullYear();
            
            const cell = document.createElement('div');
            cell.className = 'month-cell';
            // Apply dynamic width
            cell.style.flex = 'none'; // Disable flex grow
            cell.style.width = `${config.widthPercent}%`;
            
            cell.innerHTML = `<span class="year-label">${config === monthConfig[0] || m === 1 ? y + '년' : ''}</span>${m}월`;
            monthsContainer.appendChild(cell);
        });
        header.appendChild(monthsContainer);

        // 2. Group events by Category and Model
        // Get unique combinations
        const combinations = [];
        const seen = new Set();
        
        events.forEach(e => {
            const key = `${e.category || 'Uncategorized'}|${e.model}`;
            if (!seen.has(key)) {
                seen.add(key);
                combinations.push({
                    category: e.category || 'Uncategorized',
                    model: e.model
                });
            }
        });

        // Sort combinations
        combinations.sort((a, b) => {
            // Sort by Category Order
            const catIndexA = CATEGORY_ORDER.indexOf(a.category);
            const catIndexB = CATEGORY_ORDER.indexOf(b.category);
            
            if (catIndexA !== -1 && catIndexB !== -1) {
                if (catIndexA !== catIndexB) return catIndexA - catIndexB;
            } 
            else if (catIndexA !== -1) return -1;
            else if (catIndexB !== -1) return 1;
            else {
                const catCompare = a.category.localeCompare(b.category);
                if (catCompare !== 0) return catCompare;
            }
            return a.model.localeCompare(b.model);
        });
        
        // Group by Category for Rendering
        const grouped = {};
        combinations.forEach(combo => {
            if (!grouped[combo.category]) grouped[combo.category] = [];
            grouped[combo.category].push(combo);
        });
        
        // 3. Render Rows (Grouped Structure)
        // Iterate through sorted categories
        const sortedCategories = Object.keys(grouped).sort((a, b) => {
             const catIndexA = CATEGORY_ORDER.indexOf(a);
             const catIndexB = CATEGORY_ORDER.indexOf(b);
             if (catIndexA !== -1 && catIndexB !== -1) return catIndexA - catIndexB;
             if (catIndexA !== -1) return -1;
             if (catIndexB !== -1) return 1;
             return a.localeCompare(b);
        });

        sortedCategories.forEach(cat => {
            const catGroup = document.createElement('div');
            catGroup.className = 'category-group';
            
            // Category Label (Merged Cell)
            const catLabel = document.createElement('div');
            catLabel.className = 'category-name';
            catLabel.textContent = cat;
            catGroup.appendChild(catLabel);
            
            // Models Container
            const modelsContainer = document.createElement('div');
            modelsContainer.className = 'category-models';
            
            grouped[cat].forEach(combo => {
                const row = document.createElement('div');
                row.className = 'model-row';

                const nameCell = document.createElement('div');
                nameCell.className = 'model-name';
                nameCell.textContent = combo.model;
                row.appendChild(nameCell);

                const track = document.createElement('div');
                track.className = 'timeline-track';
                // Remove background gradient as it won't match variable widths easily
                track.style.backgroundImage = 'none';
                
                // Add grid lines manually to match headers
                monthConfig.forEach(config => {
                    const line = document.createElement('div');
                    line.style.position = 'absolute';
                    line.style.left = `${config.startPercent}%`;
                    line.style.width = '1px';
                    line.style.height = '100%';
                    line.style.background = '#eee';
                    line.style.zIndex = '0';
                    track.appendChild(line);
                });

                let displayEvents = [];

                if (isFullView) {
                    // Aggregation Logic for Full View
                    const modelEvents = events.filter(e => 
                        (e.category || 'Uncategorized') === combo.category && 
                        e.model === combo.model
                    );

                    // Group by Phase
                    const phaseGroups = {};
                    modelEvents.forEach(e => {
                        // Use phase if available, otherwise fallback to name (for old data)
                        const p = e.phase || e.name.split(' ')[0]; 
                        if (!phaseGroups[p]) phaseGroups[p] = [];
                        phaseGroups[p].push(e);
                    });

                    Object.keys(phaseGroups).forEach(p => {
                        const group = phaseGroups[p];
                        // Find min start and max end
                        let minStart = group[0].start;
                        let maxEnd = group[0].end;
                        
                        group.forEach(g => {
                            if (g.start < minStart) minStart = g.start;
                            if (g.end > maxEnd) maxEnd = g.end;
                        });

                        displayEvents.push({
                            id: 'aggregated-' + Date.now() + Math.random(), // Dummy ID
                            isAggregated: true,
                            category: combo.category,
                            model: combo.model,
                            name: p, // Just the phase name
                            start: minStart,
                            end: maxEnd,
                            color: group[0].color,
                            position: group[0].position
                        });
                    });

                } else {
                    // Normal View: Show all events individually
                    displayEvents = events.filter(e => 
                        (e.category || 'Uncategorized') === combo.category && 
                        e.model === combo.model
                    );
                }
                
                displayEvents.forEach(evt => {
                    const bar = createEventBar(evt, getDatePosition);
                    track.appendChild(bar);
                });

                row.appendChild(track);
                modelsContainer.appendChild(row);
            });
            
            catGroup.appendChild(modelsContainer);
            body.appendChild(catGroup);
        });
    }

    function createEventBar(evt, getDatePosition) {
        const startDate = new Date(evt.start);
        const endDate = new Date(evt.end);
        
        const startPercent = getDatePosition(startDate);
        const endPercent = getDatePosition(endDate);
        const widthPercent = endPercent - startPercent;

        // If width is negative or zero (out of range or invalid)
        if (widthPercent <= 0) {
             const hidden = document.createElement('div');
             hidden.style.display = 'none';
             return hidden;
        }
        
        const bar = document.createElement('div');
        bar.className = 'event-bar';
        if (evt.position === 'bottom') {
            bar.classList.add('phase-2');
        }
        
        bar.style.left = `${startPercent}%`;
        bar.style.width = `${widthPercent}%`;
        bar.style.backgroundColor = evt.color;
        
        // Delete button only for non-aggregated events
        const deleteBtn = evt.isAggregated ? '' : `<button class="delete-btn" onclick="deleteEvent(${evt.id}); event.stopPropagation();">×</button>`;
        
        bar.innerHTML = `
            <div>${evt.name}</div>
            <div class="dates">${formatDate(startDate)} ~ ${formatDate(endDate)}</div>
            ${deleteBtn}
        `;

        bar.addEventListener('mousemove', (e) => {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';
            tooltip.style.left = e.pageX + 10 + 'px';
            tooltip.style.top = e.pageY + 10 + 'px';
            tooltip.innerHTML = `
                <strong>${evt.model} - ${evt.name}</strong><br>
                ${evt.start} ~ ${evt.end}
            `;
        });
        
        bar.addEventListener('mouseleave', () => {
            document.getElementById('tooltip').style.display = 'none';
        });

        return bar;
    }

    function formatDate(date) {
        return `${date.getMonth() + 1}/${date.getDate()}`;
    }
</script>

</body>
</html>
